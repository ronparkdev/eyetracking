<!DOCTYPE html>
<html>
<head>
  <script async src="./opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
</head>
<body>
  <h1>눈 감음 감지</h1>
  <video id="video" width="640" height="480" autoplay></video>
  <canvas id="canvas" width="640" height="480"></canvas>

  <script type="text/javascript">
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvas');
    let context = canvas.getContext('2d');
    let classifier;
    let eyesClosed = false;
    let cascadeFile = './haarcascade_eye.xml'; // 원격 URL에서 눈 감음 분류자 파일을 가져옴

    async function onOpenCvReady() {
      console.log('OpenCV.js is ready');
      await loadClassifier();
      requestCameraPermission();
    }

    async function downloadFileAndHash(url) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to download file from ${url}, status: ${response.status}`);
      }
      
      const arrayBuffer = await response.arrayBuffer();
      const data = new Uint8Array(arrayBuffer);
      
      // 파일 데이터를 해싱하여 파일명 생성
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');
      
      // 확장자 추출
      const fileExtension = url.split('.').pop();
      
      // 해시된 파일명 생성
      const hashedFileName = `${hashHex}.${fileExtension}`;
      
      // 파일을 로컬에 저장 (FS_createDataFile 함수 포함)
      cv.FS_createDataFile('/', hashedFileName, data, true, false, false);
      console.log(`다운로드 및 해싱 완료. 해시된 파일명: ${hashedFileName}`);
      
      // 해시된 파일명 반환
      return `/${hashedFileName}`;
    }

    async function loadClassifier() {
      await new Promise(resolve => {
        cv.onRuntimeInitialized = resolve;
      });
      const cascadeFilePath = await downloadFileAndHash(cascadeFile);
      classifier = new cv.CascadeClassifier();
      let loadClassifierStatus = classifier.load(cascadeFilePath);
      console.log('Classifier loaded:', loadClassifierStatus);
    }

    function requestCameraPermission() {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(function (stream) {
          video.srcObject = stream;
          video.play();
          detectEyes();
        })
        .catch(function (err) {
          console.error('Error accessing the camera:', err);
        });
    }

    function detectEyes() {
      const FPS = 30;
      setInterval(function () {
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        let src = cv.imread(canvas);
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        let eyes = new cv.RectVector();
        classifier.detectMultiScale(gray, eyes);
        
        if (eyes.size() === 0) {
          if (!eyesClosed) {
            console.log('눈을 감음 감지');
            eyesClosed = true;
          }
        } else {
          eyesClosed = false;
        }

        src.delete();
        gray.delete();
        eyes.delete();
      }, 1000 / FPS);
    }
  </script>
</body>
</html>
